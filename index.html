<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>üéÅ Web Puzzle Hub</title>
<style>
  /* === Root & general styles === */
  :root {
    --pairs: 2;
    --stage1-time: 60;
    --seq-count: 2; /* number of questions in puzzle 2 */
    --memorise-time: 2;
    --stage2-time: 45;
    --stage3-icons: 4;
    --stage3-start-len: 3;
    --stage3-show-time: 800;
    --stage3-max-level: 2;
  }
  * {
    box-sizing: border-box;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen,
      Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  }
  body {
    margin: 0; padding: 2rem; min-height: 100vh;
    background: #ffe6f0;
    color: #4a154b;
    display: flex; flex-direction: column; align-items: center;
    transition: background 0.3s ease;
  }
  h1, h2, h3 {
    margin-top: 0; text-align: center;
  }
  button {
    cursor: pointer;
    padding: 0.6rem 1.2rem;
    border: none;
    border-radius: 8px;
    font-size: 1rem;
    background: #d147a3;
    color: #fff;
    transition: background 0.2s, transform 0.1s ease;
    user-select: none;
  }
  button:hover {
    background: #ae3d8f;
  }
  button:active {
    transform: scale(0.95);
  }
  input, textarea {
    font-family: inherit;
    font-size: 1rem;
    border: 2px solid #d147a3;
    border-radius: 8px;
    padding: 0.4rem 0.6rem;
    outline-offset: 2px;
    transition: border-color 0.2s;
    background: #fff0f8;
    color: #4a154b;
  }
  input:focus, textarea:focus {
    border-color: #ae3d8f;
  }
  textarea {
    resize: vertical;
    min-height: 100px;
  }
  .hidden {
    display: none !important;
  }

  #menu, #puzzle1, #secretPage {
    width: 100%;
    max-width: 600px;
  }

  /* Grid for cards */
  .grid {
    display: grid;
    gap: 0.6rem;
    margin-top: 1rem;
  }
  /* Cards */
  .card {
    position: relative;
    aspect-ratio: 1/1;
    background: #f9d7e5;
    border-radius: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 2.8rem;
    user-select: none;
    cursor: pointer;
    box-shadow: 0 3px 8px rgb(209 131 184 / 0.5);
    transition: transform 0.15s ease, background 0.3s ease;
    border: 2px solid transparent;
  }
  .card.flipped {
    background: #fff;
    transform: scale(1.05);
    border-color: #d147a3;
    box-shadow: 0 5px 15px rgb(209 131 184 / 0.9);
  }
  .card.matched {
    background: #ffcdf3;
    cursor: default;
    box-shadow: 0 0 15px #ff73ca;
    transform: scale(1.1);
  }
  .card:active {
    transform: scale(0.95);
  }
  .card.done {
    background: #ffe0f7;
    cursor: default;
    box-shadow: none;
  }

  /* Timer style */
  #timerStage1, #timerStage2 {
    font-weight: 700;
    font-size: 1.2rem;
    text-align: center;
    margin-bottom: 1rem;
    color: #b3396a;
  }

  /* Puzzle sections */
  .stage {
    margin-top: 2rem;
  }

  /* Overlay message */
  #overlay {
    position: fixed;
    inset: 0;
    background: #000c;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 1.5rem;
    z-index: 99;
    color: #ff8ed8;
    font-size: 1.4rem;
    font-weight: 600;
    backdrop-filter: blur(5px);
  }
  #overlay.hidden {
    display: none;
  }
  #overlay button {
    background: #d147a3;
    font-weight: 700;
    padding: 0.7rem 1.5rem;
    font-size: 1.1rem;
    border-radius: 8px;
  }
  #overlay button:hover {
    background: #ae3d8f;
  }

  /* Stage 2 styles */
  #instructions2 {
    font-weight: 600;
    font-size: 1.1rem;
    margin-bottom: 0.7rem;
    color: #a92c82;
    text-align: center;
  }
  .card.done {
    cursor: default;
  }

  /* Stage 3 Simon style */
  #grid3 {
    margin-top: 1rem;
    gap: 0.8rem;
  }
  .iconBtn {
    background: #ffadea;
    font-size: 2.6rem;
    padding: 1.1rem;
    border-radius: 14px;
    cursor: pointer;
    user-select: none;
    transition: background 0.15s, transform 0.15s;
    display: flex;
    justify-content: center;
    align-items: center;
    box-shadow: 0 3px 10px rgb(255 145 208 / 0.6);
    border: 2px solid transparent;
  }
  .iconBtn.active {
    background: #ff49b8;
    transform: scale(1.3);
    box-shadow: 0 0 20px #ff00a0;
    border-color: #ff3388;
  }
  .iconBtn.disabled {
    pointer-events: none;
    opacity: 0.5;
  }
  #levelInfo {
    margin-top: 0.6rem;
    font-weight: 700;
    text-align: center;
    color: #aa2e7a;
  }

  /* Animations on press */
  .press-anim {
    animation: pressScale 0.15s ease forwards;
  }
  @keyframes pressScale {
    0% { transform: scale(1); }
    50% { transform: scale(0.85); }
    100% { transform: scale(1); }
  }

  /* Secret page dark web theme */
  body.dark {
    background: #000000;
    color: #00ff00;
    font-family: 'Courier New', monospace;
    min-height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 2rem;
    transition: background 0.3s ease;
  }
  #secretPage {
    background: #001100;
    border: 2px solid #00ff00;
    padding: 2rem;
    border-radius: 12px;
    width: 100%;
    max-width: 600px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    gap: 1rem;
    color: #00ff00;
  }
  #serialPrompt {
  display: flex;
  flex-direction: column;
  align-items: center; /* centers children horizontally */
  gap: 1rem;
}

#serialInput {
  width: 60%;
  max-width: 300px;
  padding: 0.5rem;
  font-size: 1.1rem;
  border-radius: 8px;
  border: 2px solid #00ff00;
  background: #002200;
  color: #00ff00;
  text-align: center; /* centers the text inside input */
}

#serialSubmitBtn,
#serialBackBtn {
  background: #00ff00;
  color: #000;
  font-weight: bold;
  border: none;
  border-radius: 8px;
  width: 140px;
  padding: 0.5rem 0;
  cursor: pointer;
  transition: background 0.2s ease;
}

#serialSubmitBtn:hover,
#serialBackBtn:hover {
  background: #00cc00;
  color: #fff;
}
  #secretOutput {
    background: #002200;
    border: 1.5px solid #00ff00;
    border-radius: 6px;
    padding: 1rem;
    min-height: 60px;
    white-space: pre-wrap;
    font-family: 'Courier New', monospace;
    user-select: text;
    margin-bottom: 1rem;
    font-size: 1.1rem;
  }
   button#serialSubmitBtn {
    background: #00ff00;
    color: #000000;
    font-weight: bold;
    align-self: center;
    width: 140px;
  }
  button#serialSubmitBtn:hover {
    background: #00cc00;
    color: #fff;
  }

  button#backToMenuBtn {
    background: #00ff00;
    color: #000000;
    font-weight: bold;
    align-self: center;
    width: 140px;
  }
  button#backToMenuBtn:hover {
    background: #00cc00;
    color: #fff;
  }
 decryptUI {
  background-color: #2a2a2a; /* dark background for the section */
  color: #eee; /* light text color */
  padding: 1rem;
  border-radius: 8px;
}

#decryptUI input,
#decryptUI textarea {
  background-color: #444;  /* dark input background */
  color: #eee;             /* light text */
  border: 1px solid #666;  /* subtle border */
  border-radius: 4px;
  padding: 0.5rem;
  font-size: 1rem;
  font-family: monospace, monospace;
  outline-offset: 2px;
  transition: border-color 0.3s ease;
}

#decryptUI input,
#decryptUI textarea {
  background: #002200;          /* same as secretInput background */
  color: #00ff00;               /* bright green text */
  border: 1.5px solid #00ff00; /* bright green border */
  border-radius: 8px;
  padding: 0.6rem 1rem;
  font-family: 'Courier New', monospace;
  font-size: 1rem;
  outline-offset: 2px;
  transition: border-color 0.2s ease;
}

#decryptUI input:focus,
#decryptUI textarea:focus {
  border-color: #00cc00;        /* slightly brighter green on focus */
  box-shadow: 0 0 6px #00cc00aa;
  outline: none;
}

.codeBox {
  width: 2.5rem;
  text-align: center;
  font-weight: bold;
  font-size: 1.2rem;
  margin-right: 0.4rem;
  background-color: #002200;
  color: #00ff00;
  border: 1.5px solid #00ff00;
  border-radius: 8px;
  font-family: 'Courier New', monospace;
}
  #codeWrap {
    display: flex;
    margin-bottom: 1rem;
  }
  #menu {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1rem;
  padding-top: 2rem; /* add some top space */
}

#menu button, #menu input {
  width: 220px;  /* consistent width */
  max-width: 90vw;
  font-size: 1.1rem;
}

#passwordContainer {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  width: 220px; /* same width as buttons for consistency */
  max-width: 90vw;
  margin: 0 auto 1rem auto; /* center and add bottom spacing */
}

#passwordContainer input {
  flex: 1;
  font-size: 1.1rem;
}

#passwordContainer button {
  flex-shrink: 0;
  font-size: 1.1rem;
  width: auto;            /* width fits content */
  min-width: 50px;        /* optional min width for consistency */
}
#secretOverlay {
  position: fixed;
  inset: 0;
  background: rgba(209, 67, 163, 0.9); /* semi-transparent pink */
  backdrop-filter: blur(6px);
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  gap: 1rem;
  z-index: 1000;
  color: #fff;
  font-weight: 600;
  border-radius: 12px;
  padding: 2rem;
  box-shadow: 0 0 20px #d147a3;
}

#secretOverlay input,
#secretOverlay button {
  font-family: inherit;
  font-size: 1rem;
  border-radius: 8px;
  border: none;
  padding: 0.5rem 1rem;
  outline-offset: 2px;
}

#secretOverlay input {
  width: 240px;
  border: 2px solid #fff0f8;
  background: #fff0f8;
  color: #4a154b;
}

#secretOverlay button {
  background: #d147a3;
  color: #fff;
  cursor: pointer;
  transition: background 0.2s ease;
}

#secretOverlay button:hover {
  background: #ae3d8f;
}

#overlayError {
  color: #ffccd9;
  min-height: 1.5rem;
  font-size: 0.9rem;
  text-align: center;
}

button#backToMenuBtn {
  background: #00ff00;
  color: #000000;
  font-weight: bold;
  align-self: center;
  width: 140px;
}
button#backToMenuBtn:hover {
  background: #00cc00;
  color: #fff;
}

</style>
</head>
<body>
<!-- ===== Main Menu ===== -->
<section id="menu">
  <h1>üéÅ Web Puzzle Hub</h1>
  <button id="startPuzzle1">Puzzle 1 ‚Äì Memory</button>
  <button id="openSecretOverlay">Secret Page</button>
</section>

<!-- ===== Secret Password Overlay ===== -->
<div id="secretOverlay" class="hidden">
  <div class="overlayContent">
    <h2>Enter Secret Password</h2>
    <input id="overlayPasswordInput" type="password" placeholder="Password" autocomplete="off" />
    <div id="overlayError" style="color:#f66; margin-top:0.5rem; min-height:1.2em;"></div>
    <div style="margin-top:1rem;">
      <button id="overlayEnterBtn">Enter</button>
      <button id="overlayCancelBtn">Cancel</button>
    </div>
  </div>
</div>

<!-- ===== Puzzle 1 Container ===== -->
<section id="puzzle1" class="hidden">
  <h2>Puzzle 1 ‚Äì Double Memory</h2>

  <!-- Stage 1: Pair matching -->
  <article id="stage1" class="stage">
    <h3>Stage 1 ‚Äì Find all pairs</h3>
    <div id="timerStage1">‚è≥ <span id="time1"></span></div>
    <div id="grid1" class="grid"></div>
  </article>
  

  <!-- Stage 2: Locate emoji questions -->
  <article id="stage2" class="stage hidden">
    <h3>Stage 2 ‚Äì Where is the emoji?</h3>
    <div id="instructions2">Memorise the cards, then answer questions!</div>
    <div id="timerStage2" class="timer hidden">‚è≥ <span id="time2"></span></div>
    <div id="grid2" class="grid"></div>
    <div id="questionPrompt" style="margin-top:1rem; font-weight:bold; text-align:center; font-size:1.2rem; color:#a92c82;"></div>
  </article>

  <!-- Stage 3: Simon style -->
  <article id="stage3" class="stage hidden">
    <h3>Stage 3 ‚Äì Simon Says</h3>
    <p id="info3">Watch the sequence‚Ä¶</p>
    <div id="grid3" class="grid"></div>
    <div id="levelInfo">Level: <span id="levelNum"></span></div>
  </article>
</section>

<!-- ===== Secret Page ===== -->
<section id="secretPage" class="hidden">
  <!-- Serial Prompt Section -->
  <div id="serialPrompt">
    <h2>üîê Enter Serial Number</h2>
    <input id="serialInput" maxlength="10" autocomplete="off" />
    <button id="serialSubmitBtn">Submit</button>
    <button id="serialBackBtn">Back to Menu</button>
  </div>

  <!-- Decrypt UI (part of the secretPage!) -->
  <div id="decryptUI" class="hidden">
    <h2>üíª Decryption Terminal</h2>
    <div id="codeWrap">
      <input class="codeBox" maxlength="1" />
      <input class="codeBox" maxlength="1" />
      <input class="codeBox" maxlength="1" />
      <input class="codeBox" maxlength="1" />
      <input class="codeBox" maxlength="1" />
    </div>
    <textarea id="secretInput" placeholder="Encrypted text..."></textarea>
    <pre id="secretOutput"></pre>
    <button id="backToMenuBtn">üîô Back to Menu</button>
  </div>
</section>

<!-- ===== Overlay ===== -->
<div id="overlay" class="hidden">
  <div id="overlayText"></div>
  <button id="overlayBtn">OK</button>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {

  // Util
  const $ = s => document.querySelector(s);
  const $$ = s => document.querySelectorAll(s);
  const shuffle = a => a.sort(() => Math.random() - .5);
  const delay   = ms => new Promise(r=>setTimeout(r,ms));

  // Elements
  const menu = $('#menu');
  const puzzle1 = $('#puzzle1');
  const secretPage = $('#secretPage');

  // Main menu buttons
  const startPuzzle1Btn = $('#startPuzzle1');
 // const passwordInput = $('#passwordInput');
  //const unlockSecretBtn = $('#unlockSecret');
  
  const secretOverlay = $('#secretOverlay');
  const overlayPasswordInput = $('#overlayPasswordInput');
  const overlayEnterBtn = $('#overlayEnterBtn');
  const overlayCancelBtn = $('#overlayCancelBtn');
  const overlayError = $('#overlayError');

  // Puzzle 1 elements
  const stage1 = $('#stage1');
  const stage2 = $('#stage2');
  const stage3 = $('#stage3');
  const grid1 = $('#grid1');
  const grid2 = $('#grid2');
  const grid3 = $('#grid3');
  const time1Span = $('#time1');
  const time2Span = $('#time2');
  const instructions2 = $('#instructions2');
  const timerStage2El = $('#timerStage2');
  const questionPrompt = $('#questionPrompt');
  const info3 = $('#info3');
  const levelNum = $('#levelNum');

  // Secret page elements
  const serialPrompt = $('#serialPrompt');
  const decryptUI = $('#decryptUI');
  const serialInput = $('#serialInput');
  const serialSubmitBtn = $('#serialSubmitBtn');
  const serialBackBtn = $('#serialBackBtn');
  const backToMenuBtn = $('#backToMenuBtn');
  const codeBoxes = Array.from($$('.codeBox'));
  const secretInput = $('#secretInput');
  const secretOutput = $('#secretOutput');

  // Overlay
  const overlay = $('#overlay');
  const overlayText = $('#overlayText');
  const overlayBtn = $('#overlayBtn');

  // Config
  const config = {
    pairs: +getComputedStyle(document.documentElement).getPropertyValue('--pairs').trim(),
    stage1Time: +getComputedStyle(document.documentElement).getPropertyValue('--stage1-time').trim(),
    seqCount: +getComputedStyle(document.documentElement).getPropertyValue('--seq-count').trim(),
    memoriseTime: +getComputedStyle(document.documentElement).getPropertyValue('--memorise-time').trim(),
    stage2Time: +getComputedStyle(document.documentElement).getPropertyValue('--stage2-time').trim(),
    stage3Icons: +getComputedStyle(document.documentElement).getPropertyValue('--stage3-icons').trim(),
    stage3StartLen: +getComputedStyle(document.documentElement).getPropertyValue('--stage3-start-len').trim(),
    stage3Show: +getComputedStyle(document.documentElement).getPropertyValue('--stage3-show-time').trim(),
    stage3Max: +getComputedStyle(document.documentElement).getPropertyValue('--stage3-max-level').trim(),
  };
  
  // Buttons
    const openSecretOverlayBtn = document.getElementById('openSecretOverlay');

    openSecretOverlayBtn.onclick = () => {
      overlayError.textContent = '';
      overlayPasswordInput.value = '';
      secretOverlay.classList.remove('hidden');
      overlayPasswordInput.focus();
    };

    overlayEnterBtn.onclick = () => {
      const val = overlayPasswordInput.value.trim();
      if(val === 'X'){
        secretOverlay.classList.add('hidden');
        menu.classList.add('hidden');
        secretPage.classList.remove('hidden');
        document.body.classList.add('dark');
      } else {
        overlayError.textContent = 'Incorrect password, try again.';
      }
    };

    overlayCancelBtn.onclick = () => {
      secretOverlay.classList.add('hidden');
    };

    // Optional: Allow pressing Enter key to submit password
    overlayPasswordInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        overlayEnterBtn.click();
      }
    });
	
	backToMenuBtn?.addEventListener('click', () => {
  secretPage.classList.add('hidden');
    document.body.classList.remove('dark');  // <-- ADD THIS LINE

  showMenu();
});

  // Emojis for puzzles
  const EMOJI = [
    'üê∂','üê±','ü¶ä','üêº','üê∏','üêµ','üêß','ü¶Ñ','üêô','üêù','ü¶ã','üê¢','üçé','üçã','üçá','üçì','ü•ë','ü•ï','üçï','üç™','‚öΩ','üèÄ','üé≤','üéπ','üöó','‚úàÔ∏è','üöÄ','üåà','‚≠ê','üî•','‚ùÑÔ∏è','üíé','üéÅ'
  ];

  // Game State for Puzzle 1 Stage 1
  let firstCard = null, lock = false, matched = 0, timer1, timeLeft1;

  // Game State for Puzzle 1 Stage 2
  let memoriseTimer, memoriseInterval, timer2, timeLeft2;
  let questionsAsked = 0;
  let questionMax;
  let questionSequence = [];
  let questionCurrentIndex;
  let cardPositions = []; // card emoji order by position index

  // Game State for Puzzle 3
  let seq3 = [], level = 0, acceptingInput = false, buttons3 = [], playerIndex = 0;

  // Sound utility
  function playSound(freq=440, duration=150) {
    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const osc = ctx.createOscillator();
      const gainNode = ctx.createGain();
      osc.frequency.value = freq;
      osc.type = 'triangle';
      osc.connect(gainNode);
      gainNode.connect(ctx.destination);
      osc.start();
      gainNode.gain.setValueAtTime(0.2, ctx.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration/1000);
      osc.stop(ctx.currentTime + duration/1000);
    } catch(e) {
      // AudioContext might be blocked, ignore
    }
  }

  // Helper: show overlay message
  function showMsg(text, btnText='OK', onClose=null) {
    overlayText.textContent = text;
    overlayBtn.textContent = btnText;
    overlay.classList.remove('hidden');
    overlayBtn.onclick = () => {
      overlay.classList.add('hidden');
      if (onClose) onClose();
    };
  }

  // Show/hide sections
  function hideAll() {
    menu.classList.add('hidden');
    puzzle1.classList.add('hidden');
    secretPage.classList.add('hidden');
    document.body.classList.remove('dark');
  }
  function showMenu() {
    hideAll();
    menu.classList.remove('hidden');
  }

  /* ===== Menu Buttons ===== */
  startPuzzle1Btn.onclick = () => {
    hideAll();
    puzzle1.classList.remove('hidden');
    startStage1();
  };



  /* ===== Secret Page Events ===== */
serialSubmitBtn?.addEventListener('click', () => {
  console.log('[serial] Submit clicked');
  const val = serialInput.value.trim();
  if (val === 'XXX') {
    serialPrompt.classList.add('hidden');
    decryptUI.classList.remove('hidden');
    serialInput.value = '';
  } else {
    alert('Wrong serial number ‚Üí back to menu');
    secretPage.classList.add('hidden');
    menu.classList.remove('hidden');
    decryptUI.classList.add('hidden');
    serialPrompt.classList.remove('hidden');
    serialInput.value = '';
  }
});

serialBackBtn?.addEventListener('click', () => {
  console.log('[serial] Back clicked');

  secretPage.classList.add('hidden');
  menu.classList.remove('hidden');

  decryptUI.classList.add('hidden');
  serialPrompt.classList.remove('hidden');
  serialInput.value = '';

  document.body.classList.remove('dark');
});

serialInput?.addEventListener('keydown', e => {
  if (e.key === 'Enter') {
    serialSubmitBtn?.click();
  }
});

  // Decrypt logic
  function updateDecrypt() {
    const key = codeBoxes.map(box => box.value.toUpperCase()).join('');
    const input = secretInput.value;
    if (key === 'DUCKS') {
      secretOutput.textContent = input === 'klo aws qwerty b√§lk√∂' ? 'Ankan flyger i √∂st' : '[unknown message]';
    } else {
      // Fake decrypt: XOR each char with 7
      secretOutput.textContent = '‚ñì‚ñí‚ñë ' + input.split('').map(ch => String.fromCharCode(ch.charCodeAt(0)^7)).join('') + ' ‚ñë‚ñí‚ñì';
    }
  }
  codeBoxes.forEach(box => box.addEventListener('input', updateDecrypt));
  secretInput.addEventListener('input', updateDecrypt);

  /* ===== Puzzle 1 Stage 1 ‚Äì Find pairs ===== */
  function startStage1() {
    firstCard = null;
    lock = false;
    matched = 0;
    timeLeft1 = config.stage1Time;
    time1Span.textContent = timeLeft1 + 's';
    stage1.classList.remove('hidden');
    stage2.classList.add('hidden');
    stage3.classList.add('hidden');

    // Prepare cards with pairs
    const cardsCount = config.pairs * 2;
    const selectedEmojis = shuffle(EMOJI).slice(0, config.pairs);
    const pairsArray = shuffle([...selectedEmojis, ...selectedEmojis]);

    // Clear previous
    grid1.innerHTML = '';
    grid1.style.gridTemplateColumns = `repeat(4, 1fr)`;

    // Create cards
    for (let i = 0; i < cardsCount; i++) {
      const card = document.createElement('div');
      card.className = 'card';
      card.dataset.emoji = pairsArray[i];
      card.textContent = '';
      card.setAttribute('aria-label', 'card');
      card.tabIndex = 0;

      card.onclick = () => {
        if (lock || card.classList.contains('flipped') || card.classList.contains('matched')) return;
        flipCard(card);
      };
      card.onkeydown = (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          card.click();
        }
      };
      grid1.appendChild(card);
    }

    // Timer countdown
    clearInterval(timer1);
    timer1 = setInterval(() => {
      timeLeft1--;
      time1Span.textContent = timeLeft1 + 's';
      if (timeLeft1 <= 0) {
        clearInterval(timer1);
        failStage1();
      }
    }, 1000);
  }
  // Flip card logic
  function flipCard(card) {
    if (lock) return;
    playSound(523); // C5
    card.classList.add('flipped', 'press-anim');
    card.textContent = card.dataset.emoji;
    setTimeout(() => card.classList.remove('press-anim'), 150);

    if (!firstCard) {
      firstCard = card;
      return;
    }
    lock = true;
    if (card.dataset.emoji === firstCard.dataset.emoji) {
      // Matched pair
      playSound(784); // G5
      card.classList.add('matched');
      firstCard.classList.add('matched');
      matched += 2;
      firstCard = null;
      lock = false;
      if (matched === config.pairs * 2) {
        clearInterval(timer1);
        showMsg('Stage 1 complete! Moving to Stage 2...', 'Next', startStage2);
      }
    } else {
      // Not matched, flip back after delay
      playSound(196); // G3 low fail sound
      setTimeout(() => {
        card.classList.remove('flipped');
        card.textContent = '';
        firstCard.classList.remove('flipped');
        firstCard.textContent = '';
        firstCard = null;
        lock = false;
      }, 900);
    }
  }
  function failStage1() {
    showMsg('Time is up! Try Stage 1 again.', 'Retry', startStage1);
  }

  /* ===== Puzzle 1 Stage 2 ‚Äì Where is the emoji? ===== */
  
  // Track answered cards indexes
	let answeredCards = new Set();
  
  function startStage2() {
  stage1.classList.add('hidden');
  stage2.classList.remove('hidden');
  stage3.classList.add('hidden');

  // Clear previous timers and state
  clearInterval(memoriseTimer);
  clearInterval(timer2);
  lock = false;

  questionCurrentIndex = 0;
  questionsAsked = 0;
  questionMax = config.seqCount;

  // Prepare cards
  const totalCards = config.pairs;
  const selectedEmojis = shuffle(EMOJI).slice(0, totalCards);
  cardPositions = selectedEmojis.slice(); // stable order

  // Render cards face-up for memorization
  grid2.innerHTML = '';
  grid2.style.gridTemplateColumns = `repeat(4, 1fr)`;
  cardPositions.forEach(emoji => {
    const card = document.createElement('div');
    card.className = 'card done';
    card.textContent = emoji;
    card.style.background = ''; // reset background in case it was changed
    card.onclick = null; // remove any old handlers
    grid2.appendChild(card);
  });

  instructions2.textContent = `Memorise the cards! You have ${config.memoriseTime} seconds.`;
  questionPrompt.textContent = '';
  timerStage2El.classList.add('hidden');

  // Start memorization countdown
  let memTimeLeft = config.memoriseTime;
  memoriseTimer = setInterval(() => {
    memTimeLeft--;
    instructions2.textContent = `Memorise the cards! You have ${memTimeLeft} second${memTimeLeft !== 1 ? 's' : ''}.`;
    if (memTimeLeft <= 0) {
      clearInterval(memoriseTimer);
      beginQuestionPhase();
    }
  }, 1000);
}

function failStage2() {
  clearInterval(memoriseTimer);
  clearInterval(timer2);
  lock = false;
  showMsg('Time is up or wrong card! Try Stage 2 again.', 'Retry', startStage2);
}

function beginQuestionPhase() {
  grid2.querySelectorAll('.card').forEach(card => {
    card.textContent = '';
    card.classList.remove('done');
    card.style.cursor = 'pointer';
    card.style.background = '#f9d7e5';
    card.onclick = cardClickHandler;
  });
  instructions2.textContent = 'Where is this emoji? Click the correct card.';
  timerStage2El.classList.remove('hidden');
  timeLeft2 = config.stage2Time;
  time2Span.textContent = timeLeft2 + 's';

  // Shuffle a copy for the questions so cardPositions stays intact
  questionSequence = shuffle(cardPositions.slice()).slice(0, questionMax);
  questionCurrentIndex = 0;

  clearInterval(timer2);
  timer2 = setInterval(() => {
    timeLeft2--;
    time2Span.textContent = timeLeft2 + 's';
    if (timeLeft2 <= 0) {
      clearInterval(timer2);
      failStage2();
    }
  }, 1000);

  askNextQuestion();
}

function askNextQuestion() {
  if (questionCurrentIndex >= questionSequence.length) {
    clearInterval(timer2);
    showMsg('Stage 2 complete! Moving to Stage 3...', 'Next', startStage3);
    return;
  }
  const emojiToFind = questionSequence[questionCurrentIndex];
  questionPrompt.textContent = `Where is this emoji? ${emojiToFind}`;
}

  
function cardClickHandler(e) {
  if (lock) return;
  const clickedCard = e.currentTarget;
  const clickedIndex = Array.from(grid2.children).indexOf(clickedCard);

  // Prevent clicking same card again if already answered
  if (answeredCards.has(clickedIndex)) return;

  lock = true;
  const emojiToFind = questionSequence[questionCurrentIndex];

  playSound(523);
  clickedCard.classList.add('press-anim');
  setTimeout(() => clickedCard.classList.remove('press-anim'), 150);

  if (cardPositions[clickedIndex] === emojiToFind) {
    // Correct
    clickedCard.textContent = emojiToFind;
    clickedCard.style.background = '#a2d9a2'; // green background for correct
    clickedCard.style.cursor = 'default';
    answeredCards.add(clickedIndex);

    questionCurrentIndex++;
    lock = false;

    if (questionCurrentIndex >= questionSequence.length) {
      clearInterval(timer2);
      showMsg('Stage 2 complete! Moving to Stage 3...', 'Next', startStage3);
    } else {
      askNextQuestion();
    }
  } else {
    // Wrong
    playSound(196);
    showMsg('Wrong card! Try Stage 2 again.', 'Retry', startStage2);
  }
}

  function failStage2(){
    lock=false;clearInterval(timer2);
    showMsg('Time up! Try again.','Retry',startStage2);
  }

  /* ===== Puzzle 1 Stage 3 ‚Äì Simon Says ===== */
function startStage3() {
  stage1.classList.add('hidden');
  stage2.classList.add('hidden');
  stage3.classList.remove('hidden');
  
  seq3 = [];
  level = 1;
  playerIndex = 0;
  acceptingInput = false;  // start false while sequence is shown
  buttons3 = [];
  levelNum.textContent = level;

  grid3.innerHTML = '';
  grid3.style.gridTemplateColumns = `repeat(${config.stage3Icons}, 1fr)`;

  const icons = shuffle(EMOJI).slice(0, config.stage3Icons);

  icons.forEach(icon => {
    const btn = document.createElement('button');
    btn.className = 'iconBtn disabled'; // disabled initially
    btn.textContent = icon;
    btn.dataset.icon = icon;
    btn.disabled = false; // no HTML disabled attribute
    
    btn.onclick = () => {
      if (!acceptingInput) return;  // ignore if not accepting input
      playSound(523);
      animatePress(btn);
      if (icon === seq3[playerIndex]) {
        playerIndex++;
        if (playerIndex === seq3.length) {
          level++;
          if (level > config.stage3Max) {
            showMsg('üéâ Congratulations! You completed all stages! üéâ', 'Finish', showMenu);
            return;
          }
          levelNum.textContent = level;
          acceptingInput = false;
          buttons3.forEach(b => b.classList.add('disabled'));
          playerIndex = 0;
          setTimeout(() => {
            nextSimonSequence();
          }, 1000);
        }
      } else {
        playSound(196);
        showMsg('Wrong button! Try Stage 3 again.', 'Retry', startStage3);
      }
    };

    buttons3.push(btn);
    grid3.appendChild(btn);
  });

  nextSimonSequence();
}

async function nextSimonSequence() {
  const availableIcons = buttons3.map(b => b.dataset.icon);
  const newIcon = availableIcons[Math.floor(Math.random() * availableIcons.length)];
  seq3.push(newIcon);

  info3.textContent = 'Watch the sequence‚Ä¶';
  acceptingInput = false;
  buttons3.forEach(b => b.classList.add('disabled'));

  for (const icon of seq3) {
    const btn = buttons3.find(b => b.dataset.icon === icon);
    btn.classList.add('active');
    playSound(523 + Math.random() * 200);
    await delay(config.stage3Show);
    btn.classList.remove('active');
    await delay(250);
  }

  info3.textContent = 'Your turn! Repeat the sequence.';
  acceptingInput = true;
  buttons3.forEach(b => b.classList.remove('disabled'));
  playerIndex = 0;
}

function animatePress(el) {
  el.classList.add('press-anim');
  setTimeout(() => el.classList.remove('press-anim'), 150);
}

  /* ===== Initialize ===== */
  showMenu();
})();
</script>
</body>
</html>