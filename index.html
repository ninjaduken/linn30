<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>üéÅLinn 30üéÅ</title>
<style>
  /* === Root & general styles === */
  :root {
    --pairs: 1; /* 16 */
    --stage1-time: 60;
    --seq-count: 1; /* number of questions in puzzle 2 5*/
	--stage2-cards: 1; /* number of questions in puzzle 2 */
    --memorise-time: 1;
    --stage2-time: 66;
    --stage3-icons: 12;
    --stage3-start-len: 3;
    --stage3-show-time: 800;
    --stage3-max-level: 14;
  }
  * {
    box-sizing: border-box;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen,
      Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  }
  html {
  overflow-x: hidden;
	}
  body {
  overflow-x: hidden;
    margin: 0; padding: 1rem; min-height: 100vh;
    background: #ffe6f0;
    color: #4a154b;
    display: flex; flex-direction: column; align-items: center;
    transition: background 0.3s ease;
  }
  @media (max-width: 480px) {
  body {
    padding: 0.5rem;
  }
}
  h1, h2, h3 {
    margin-top: 0; text-align: center;
  }
  button {
    cursor: pointer;
    padding: 0.6rem 1.2rem;
    border: none;
    border-radius: 8px;
    font-size: 1rem;
    background: #d147a3;
    color: #fff;
    transition: background 0.2s, transform 0.1s ease;
    user-select: none;
  }
  button:hover {
    background: #ae3d8f;
  }

button:active {
  background-color: #ff49b8;  /* bright pink, visible */
  transform: scale(0.95);     /* slightly smaller for pressed effect */
  transition: background 0.2s, transform 0.1s ease;
  color: #fff;                /* keep text white */
  outline: none;
}
  input, textarea {
    font-family: inherit;
    font-size: 1rem;
    border: 2px solid #d147a3;
    border-radius: 8px;
    padding: 0.4rem 0.6rem;
    outline-offset: 2px;
    transition: border-color 0.2s;
    background: #fff0f8;
    color: #4a154b;
  }
  input:focus, textarea:focus {
    border-color: #ae3d8f;
  }
  textarea {
    resize: vertical;
    min-height: 100px;
  }
  .hidden {
    display: none !important;
  }

  #menu, #puzzle1, #secretPage {
    width: 100%;
    max-width: 600px;
  }

  /* Grid for cards */
  .grid {
    display: grid;
	grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
    gap: 0.6rem;
    margin-top: 1rem;
  }
  .grid.disabled .card {
  pointer-events: none;
  cursor: default;
  opacity: 1; /* keep visible but not interactive */
}
  /* Cards */
  .card {
    position: relative;
    aspect-ratio: 1/1;
    background: #f9d7e5;
    border-radius: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 2.8rem;
    user-select: none;
    cursor: pointer;
    box-shadow: 0 3px 8px rgb(209 131 184 / 0.5);
    transition: transform 0.15s ease, background 0.3s ease;
    border: 2px solid transparent;
  }
  .card.flipped {
    background: #fff;
    transform: scale(1.05);
    border-color: #d147a3;
    box-shadow: 0 5px 15px rgb(209 131 184 / 0.9);
  }
  .card.matched {
    background: #ffcdf3;
    cursor: default;
    box-shadow: 0 0 15px #ff73ca;
    transform: scale(1.1);
  }
  .card:active {
    transform: scale(0.95);
  }
  .card.done {
    background: #ffe0f7;
    cursor: default;
    box-shadow: none;
  }

  /* Timer style */
  #timerStage1 {
    font-weight: 700;
    font-size: 2rem;
    text-align: center;
    margin-bottom: 1rem;
    color: #b3396a;
  }

  /* Puzzle sections */
  .stage {
    margin-top: 2rem;
  }

  /* Overlay message */
  #overlay {
    position: fixed;
    inset: 0;
    background: #000c;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 1.5rem;
    z-index: 99;
    color: #ff8ed8;
    font-size: 1.4rem;
    font-weight: 600;
    backdrop-filter: blur(5px);
  }
  #overlay.hidden {
    display: none;
  }
  #overlay button {
    background: #d147a3;
    font-weight: 700;
    padding: 0.7rem 1.5rem;
    font-size: 1.1rem;
    border-radius: 8px;
  }
  #overlay button:hover {
    background: #ae3d8f;
  }

  /* Stage 2 styles */

/* Reserve fixed height for timer area */
#timerStage2 {
  height: 2.5rem;       /* fix the height to reserve vertical space */
  margin-bottom: 1rem;
  font-weight: 700;
  font-size: 2rem;
  text-align: center;
  color: #b3396a;
  box-sizing: border-box;
}

/* Instead of display:none, hide timer visually but keep space */
.timer-invisible {
  visibility: hidden;
}
  #instructions2 {
    font-weight: 600;
    font-size: 1.1rem;
    margin-bottom: 0.7rem;
    color: #a92c82;
    text-align: center;
  }
  .card.done {
    cursor: default;
  }
  
  #questionPrompt {
  margin-top: 1rem;
  font-weight: bold;
  text-align: center;
  font-size: 4rem; /* Ensures emoji is large */
  color: #a92c82;
  line-height: 1.2;
}
.bigEmoji {
  font-size: 4rem;
  display: inline-block;
  vertical-align: middle;
  line-height: 1;
}

  /* Stage 3 Simon style */
#stage3 {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1rem; /* optional for spacing between children */
}

#puzzle3Container {
  width: 100%;
  max-width: 600px;
 overflow: visible !important;
  position: relative; /* keep layout sane */
  -webkit-overflow-scrolling: touch; /* smooth scrolling on iOS */
  padding-bottom: 0.5rem; /* optional padding for scrollbar space */
}

#grid3 {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 0.6rem;
  width: 100%;
  max-width: 100%;
  box-sizing: border-box;
  overflow: visible !important;
  position: relative;
  gap: 0.6rem;
}

#grid3.hidden {
  display: none;
}
  
#info3, #levelInfo {
  display: none;
  font-family: inherit;
  font-weight: 600;
  color: #aa2e7a;
  text-align: center;
}

#startStage3Btn {
  display: block;
  margin: 1.5rem auto 1rem auto; /* auto left and right margins centers block */
  padding: 0.7rem 1.5rem;
  font-size: 1.2rem;
  background: #d147a3;
  color: white;
  border: none;
  border-radius: 10px;
  cursor: pointer;
  user-select: none;
  max-width: 200px;
  text-align: center;
}

#startStage3Btn:hover {
  background: #ae3d8f;
}

#puzzle3Container {
  width: 100%;
  max-width: 600px;
}
@media (hover: hover) {
  /* Desktop only: apply hover */
  .card:hover,
  .iconBtn:hover  {
    background-color: #ff49b8;
  }
}

@media (hover: none) {
  /* Touch devices: disable hover styles */
  .card:hover,
  .iconBtn:hover {
    background-color: #f9d7e5;
  }
}
@media (hover: none), (pointer: coarse) {
  button:hover {
    background: inherit; /* or background: transparent; */
  }
}

.card,
.iconBtn {
  -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
}
  
.iconBtn {
  aspect-ratio: 1 / 1;
  width: 100%;
  font-size: clamp(2rem, 6vw, 2.8rem);
  background: #f9d7e5;
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  box-shadow: 0 3px 8px rgb(209 131 184 / .5);
  border: 2px solid transparent;
  transition: transform .15s ease, background .3s ease;
  transform: scale(1);
  overflow: visible;
  position: relative;
  z-index: 1;          /* normal cards */
  margin: 0rem;      /* tiny gutter so 1.3√ó never clips */
  will-change: transform, opacity;
  transform-style: preserve-3d;
}
.iconBtn.active {
  background: #ff49b8 !important; /* or your preferred sequence flash color */
  transform: scale(1.2);
  box-shadow: 0 0 20px #ff00a0;
  border-color: #ff3388;
  z-index: 20;
  transform-origin: center;
  color: #000; /* optional: ensure emoji stays visible */

}
@keyframes pressScale {
  0% { transform: scale(1); }
  50% { transform: scale(1.3); }
  100% { transform: scale(1); }
}
  .iconBtn.disabled {
    pointer-events: none;
    opacity: 0.5;
  }
  #levelInfo {
    margin-top: 2rem;
    font-weight: 700;
	font-size: 1.4rem; 
    text-align: center;
    color: #aa2e7a;
  }
  /* Animations on press */
 .press-anim {
  animation: pressScale 150ms ease;
}

@keyframes pressScale {
   0% { transform: scale(1); }
   50% { transform: scale(0.85); }
   100% { transform: scale(1); }
}

  /* Secret page dark web theme */
  body.dark {
    background: #000000;
    color: #00ff00;
    font-family: 'Courier New', monospace;
    min-height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 2rem;
    transition: background 0.3s ease;
  }
  #secretPage {
    background: #001100;
    border: 2px solid #00ff00;
    padding: 2rem;
    border-radius: 12px;
    width: 100%;
    max-width: 600px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    gap: 1rem;
    color: #00ff00;
  }
  #serialPrompt {
  display: flex;
  flex-direction: column;
  align-items: center; /* centers children horizontally */
  gap: 1rem;
}

#serialInput {
  width: 60%;
  max-width: 300px;
  padding: 0.5rem;
  font-size: 1.1rem;
  border-radius: 8px;
  border: 2px solid #00ff00;
  background: #002200;
  color: #00ff00;
  text-align: center; /* centers the text inside input */
}

#serialSubmitBtn,
#serialBackBtn {
  background: #00ff00;
  color: #000;
  font-weight: bold;
  border: none;
  border-radius: 8px;
  width: 140px;
  padding: 0.5rem 0;
  cursor: pointer;
  transition: background 0.2s ease;
}

#serialSubmitBtn:hover,
#serialBackBtn:hover {
  background: #00cc00;
  color: #fff;
}
  #secretOutput {
    background: #002200;
    border: 1.5px solid #00ff00;
    border-radius: 6px;
    padding: 1rem;
    min-height: 60px;
    white-space: pre-wrap;
    font-family: 'Courier New', monospace;
    user-select: text;
    margin-bottom: 1rem;
    font-size: 1.1rem;
  }
   button#serialSubmitBtn {
    background: #00ff00;
    color: #000000;
    font-weight: bold;
    align-self: center;
    width: 140px;
  }
  button#serialSubmitBtn:hover {
    background: #00cc00;
    color: #fff;
  }

  button#backToMenuBtn {
    background: #00ff00;
    color: #000000;
    font-weight: bold;
    align-self: center;
    width: 140px;
  }
  button#backToMenuBtn:hover {
    background: #00cc00;
    color: #fff;
  }
 decryptUI {
   position: relative; /* üëà enables absolutely positioned children like duckOverlay */
  background-color: #2a2a2a; /* dark background for the section */
  color: #eee; /* light text color */
  padding: 1rem;
  border-radius: 8px;
  width: 100%;
  max-width: 600px;
  margin: 0 auto;
}

#decryptUI input,
#decryptUI textarea {
  background-color: #444;  /* dark input background */
  color: #eee;             /* light text */
  border: 1px solid #666;  /* subtle border */
  border-radius: 4px;
  padding: 0.5rem;
  font-size: 1rem;
  font-family: monospace, monospace;
  outline-offset: 2px;
  transition: border-color 0.3s ease;
}

#decryptUI input {
  background: #002200;          /* same as secretInput background */
  color: #00ff00;               /* bright green text */
  border: 1.5px solid #00ff00; /* bright green border */
  border-radius: 8px;
  padding: 0.6rem 1rem;
  font-family: 'Courier New', monospace;
  font-size: 1rem;
  outline-offset: 2px;
  transition: border-color 0.2s ease;
  width: 100%;
  box-sizing: border-box;
  height: 100px;          /* optional, for consistency */
  resize: vertical;       /* optional, lets user expand */
}

#decryptUI textarea {
  font-size: 1.2rem;
  padding: 1rem 1rem;      /* add more padding */
  font-family: 'Courier New', monospace;
  background-color: #002200;
  color: #00ff00;
  border: 1.5px solid #00ff00;
  border-radius: 8px;
  width: 100%;
  box-sizing: border-box;
  resize: vertical;
  min-height: 120px;
}

#decryptUI input:focus,
#decryptUI textarea:focus {
  border-color: #00cc00;        /* slightly brighter green on focus */
  box-shadow: 0 0 6px #00cc00aa;
  outline: none;
}

.codeBox {
  font-size: 2.4rem !important;
  font-weight: 900;
  font-family: 'Courier New', monospace;
  text-align: center;
  width: 100%;
  max-width: none;
  border: 1.5px solid #00ff00;
  border-radius: 8px;
  background-color: #002200;
  color: #00ff00;
  box-sizing: border-box;

  /* ‚ú® Remove vertical + horizontal padding */
  padding: 0 !important;
  height: 4.5rem;
  line-height: 4.5rem; /* vertically center text */
  overflow: hidden; /* prevent any accidental overflow */
}
@media (max-width: 400px) {
  .codeBox {
    font-size: 2.2rem !important;
    height: 3.8rem !important;
    line-height: 3.8rem !important;
    padding: 0 !important;
  }
}
#codeWrap {
  display: grid;
  grid-template-columns: repeat(5, minmax(0, 1fr)); /* this allows shrinking */
  gap: 0.5rem;
  margin-bottom: 1rem;
  width: 100%;
  box-sizing: border-box;
}
  #menu {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1rem;
  padding-top: 2rem; /* add some top space */
}

#menu button, #menu input {
  width: 220px;  /* consistent width */
  max-width: 90vw;
  font-size: 1.1rem;
}

#passwordContainer {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  width: 220px; /* same width as buttons for consistency */
  max-width: 90vw;
  margin: 0 auto 1rem auto; /* center and add bottom spacing */
}

#passwordContainer input {
  flex: 1;
  font-size: 1.1rem;
}

#passwordContainer button {
  flex-shrink: 0;
  font-size: 1.1rem;
  width: auto;            /* width fits content */
  min-width: 50px;        /* optional min width for consistency */
}
#secretOverlay {
  position: fixed;
  inset: 0;
  background: rgba(209, 67, 163, 0.9); /* semi-transparent pink */
  backdrop-filter: blur(6px);
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  gap: 1rem;
  z-index: 1000;
  color: #fff;
  font-weight: 600;
  border-radius: 12px;
  padding: 2rem;
  box-shadow: 0 0 20px #d147a3;
}

#secretOverlay input,
#secretOverlay button {
  font-family: inherit;
  font-size: 1rem;
  border-radius: 8px;
  border: none;
  padding: 0.5rem 1rem;
  outline-offset: 2px;
}

#secretOverlay input {
  width: 240px;
  border: 2px solid #fff0f8;
  background: #fff0f8;
  color: #4a154b;
}

#secretOverlay button {
  background: #d147a3;
  color: #fff;
  cursor: pointer;
  transition: background 0.2s ease;
}

#secretOverlay button:hover {
  background: #ae3d8f;
}

#overlayError {
  color: #ffccd9;
  min-height: 1.5rem;
  font-size: 0.9rem;
  text-align: center;
}

button#backToMenuBtn {
  background: #00ff00;
  color: #000000;
  font-weight: bold;
  align-self: center;
  width: 140px;
}
button#backToMenuBtn:hover {
  background: #00cc00;
  color: #fff;
}
#overlayText {
  white-space: pre-line;
  text-align: center;
}
#duckOverlay{
  position:fixed;
  bottom:20px;
  right:20px;
  width:50vw;               /* ‚âà half the screen */
  max-width:400px;          /* cap on desktop */
  max-height:50vh;
  opacity:0.5;              /* less transparent */
  z-index:1;
  pointer-events:none;
  user-select:none;
  transition:transform .25s ease, filter .25s ease, opacity .25s ease;
  transform-origin:center bottom;
}

.reacting {
  animation: duckReact 0.4s ease;
}

@media (max-width: 600px) {
  #duckOverlay {
    width: 280px;      /* was 140px */
    max-width: 80vw;   /* safe fallback */
    bottom: 12px;      /* small margin */
    right: 12px;
    opacity: 0.5;      /* more visible */
  }
}

@keyframes duckSquash {
  0%   { transform: scale(1, 1) rotate(0deg); }
  20%  { transform: scale(1.1, 0.9) rotate(-1deg); }
  40%  { transform: scale(0.95, 1.05) rotate(2deg); }
  60%  { transform: scale(1.05, 0.95) rotate(-1deg); }
  80%  { transform: scale(1.02, 1.02) rotate(0.5deg); }
  100% { transform: scale(1, 1) rotate(0deg); }
}

@keyframes duckReact {
  0% { transform: scale(1) rotate(0deg); }
  20% { transform: scale(1.05) rotate(-2deg); }
  50% { transform: scale(1.025) rotate(2deg); }
  80% { transform: scale(1.05) rotate(-1deg); }
  100% { transform: scale(1) rotate(0deg); }
}

#duckOverlay.reacting {
  animation: duckSquash 0.4s ease;
}

/* duck glow while typing */
.duck-glow{
  filter:drop-shadow(0 0 20px #00ffcc) drop-shadow(0 0 35px #00ffcc);
  opacity:.9;
}

* celebration spin / flash */
@keyframes duckCelebrate{
  0%{transform:rotate(0) scale(1);}
 30%{transform:rotate(15deg) scale(1.1);}
 60%{transform:rotate(-15deg) scale(1.1);}
100%{transform:rotate(0) scale(1);}
}
.duck-celebrate{
  animation:duckCelebrate .7s ease forwards;
  filter:drop-shadow(0 0 25px #ff00aa) drop-shadow(0 0 45px #ff5fd1);
  opacity:1!important;
}
#confettiCanvas{
  position:fixed;
  inset:0;                  /* full-screen */
  z-index:2;                /* above duck, below overlay dialog */
  pointer-events:none;
}

</style>
</head>
<body>
<!-- ===== Main Menu ===== -->
<section id="menu">
  <h1>üéÅ Happy Duck Palace üéÅ</h1>
  <button id="startPuzzle1">Pussel 1 ‚Äì Memory</button>
  <button id="openSecretOverlay">Secret Page!</button>
</section>

<!-- ===== Secret Password Overlay ===== -->
<div id="secretOverlay" class="hidden">
  <div class="overlayContent">
    <h2>Mata in hemligt l√∂senord</h2>
    <input id="overlayPasswordInput" type="password" placeholder="Password" autocomplete="off" />
    <div id="overlayError" style="color:#f66; margin-top:0.5rem; min-height:1.2em;"></div>
    <div style="margin-top:1rem;">
      <button id="overlayEnterBtn">Forts√§tt</button>
      <button id="overlayCancelBtn">Avbryt</button>
    </div>
  </div>
</div>

<!-- ===== Puzzle 1 Container ===== -->
<section id="puzzle1" class="hidden">
  <h2>Pussel 1 ‚Äì Memory</h2>

  <!-- Stage 1: Pair matching -->
  <article id="stage1" class="stage">
    <h3>Steg 1 ‚Äì Hitta alla par</h3>
    <div id="timerStage1">‚è≥ <span id="time1"></span></div>
    <div id="grid1" class="grid"></div>
  </article>
  

  <!-- Stage 2: Locate emoji questions -->
  <article id="stage2" class="stage hidden">
    <h3>Steg 2 ‚Äì Vart √§r emojin?</h3>
    <div id="instructions2">Memorera alla kort</div>
    <div id="timerStage2" class="timer timer-invisible">‚è≥ <span id="time2"></span></div>
    <div id="grid2" class="grid"></div>
    <div id="questionPrompt" style="margin-top:1rem; font-weight:bold; text-align:center; font-size:1.2rem; color:#a92c82;"></div>
  </article>

  <!-- Stage 3: Simon style -->
  <article id="stage3" class="stage hidden">
    <h3>Steg 3 ‚Äì F√∂lja John</h3>
    <p id="info3">Titta p√• ordningen</p>
	<button id="startStage3Btn">Starta Steg 3</button>
	<div id="puzzle3Container">
    <div id="grid3" class="grid"></div>
    <div id="levelInfo">Level: <span id="levelNum"></span></div>
	</div>
  </article>
</section>

<!-- ===== Secret Page ===== -->
<section id="secretPage" class="hidden">
  <!-- Serial Prompt Section -->
  <div id="serialPrompt">
    <h2>üîê Serial Number</h2>
    <input id="serialInput" maxlength="10" autocomplete="off" />
    <button id="serialSubmitBtn">Skicka</button>
    <button id="serialBackBtn">Tillbaka</button>
  </div>

  <!-- Decrypt UI (part of the secretPage!) -->
  <div id="decryptUI" class="hidden">
    <h2>üíª Decryption Terminal</h2>
    <div id="codeWrap">
      <input class="codeBox" maxlength="1" />
      <input class="codeBox" maxlength="1" />
      <input class="codeBox" maxlength="1" />
      <input class="codeBox" maxlength="1" />
      <input class="codeBox" maxlength="1" />
    </div>
    <textarea id="secretInput" placeholder="Encrypted text..."></textarea>
    <pre id="secretOutput"></pre>
    <button id="backToMenuBtn">üîô Tillbaka</button>
	<img id="duckOverlay" src="darkweb-duck.png" alt="Duck" />
	<canvas id="confettiCanvas" class="hidden"></canvas>

  </div>
</section>

<!-- ===== Overlay ===== -->
<div id="overlay" class="hidden">
  <div id="overlayText"></div>
  <button id="overlayBtn">OK</button>
</div>
<script>
document.addEventListener('DOMContentLoaded', () => {

  // Util
  const $ = s => document.querySelector(s);
  const $$ = s => document.querySelectorAll(s);
  const shuffle = a => a.sort(() => Math.random() - .5);
  const delay   = ms => new Promise(r=>setTimeout(r,ms));
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  // Elements
  const menu = $('#menu');
  const puzzle1 = $('#puzzle1');
  const secretPage = $('#secretPage');

  // Main menu buttons
  const startPuzzle1Btn = $('#startPuzzle1');
  
  const secretOverlay = $('#secretOverlay');
  const overlayPasswordInput = $('#overlayPasswordInput');
  const overlayEnterBtn = $('#overlayEnterBtn');
  const overlayCancelBtn = $('#overlayCancelBtn');
  const overlayError = $('#overlayError');

  // Puzzle 1 elements
  const stage1 = $('#stage1');
  const stage2 = $('#stage2');
  const stage3 = $('#stage3');
  const grid1 = $('#grid1');
  const grid2 = $('#grid2');
  const grid3 = $('#grid3');
  const time1Span = $('#time1');
  const time2Span = $('#time2');
  const instructions2 = $('#instructions2');
  const timerStage2El = $('#timerStage2');
  const questionPrompt = $('#questionPrompt');
  const info3 = $('#info3');
  const levelNum = $('#levelNum');

  // Secret page elements
  const serialPrompt = $('#serialPrompt');
  const decryptUI = $('#decryptUI');
  const serialInput = $('#serialInput');
  const serialSubmitBtn = $('#serialSubmitBtn');
  const serialBackBtn = $('#serialBackBtn');
  const backToMenuBtn = $('#backToMenuBtn');
  const codeBoxes = Array.from($$('.codeBox'));
  const secretInput = $('#secretInput');
  const secretOutput = $('#secretOutput');

  // Overlay
  const overlay = $('#overlay');
  const overlayText = $('#overlayText');
  const overlayBtn = $('#overlayBtn');
  const duck = $('#duckOverlay');        //  <<< add this near top with other elements
  const inputs = $$('#decryptUI input, #decryptUI textarea');



	//Password
	
	const puzzleConfig = {
  password: 'X',
  serialNumber: 'XXX',
  //serialNumber: 'GGJ30X0V70',
  secretPhrases: {
    'X X X': 'Ankan flyger i √∂st',
    'zen fox leap delta': 'R√§ven smyger i gryningen'
  }
};

  // Config
  const config = {
    pairs: +getComputedStyle(document.documentElement).getPropertyValue('--pairs').trim(),
    stage1Time: +getComputedStyle(document.documentElement).getPropertyValue('--stage1-time').trim(),
    seqCount: +getComputedStyle(document.documentElement).getPropertyValue('--seq-count').trim(),
	stage2Cards: +getComputedStyle(document.documentElement).getPropertyValue('--stage2-cards').trim(),
    memoriseTime: +getComputedStyle(document.documentElement).getPropertyValue('--memorise-time').trim(),
    stage2Time: +getComputedStyle(document.documentElement).getPropertyValue('--stage2-time').trim(),
    stage3Icons: +getComputedStyle(document.documentElement).getPropertyValue('--stage3-icons').trim(),
    stage3StartLen: +getComputedStyle(document.documentElement).getPropertyValue('--stage3-start-len').trim(),
    stage3Show: +getComputedStyle(document.documentElement).getPropertyValue('--stage3-show-time').trim(),
    stage3Max: +getComputedStyle(document.documentElement).getPropertyValue('--stage3-max-level').trim(),
  };
  
  // Buttons
    const openSecretOverlayBtn = $('#openSecretOverlay');

if (openSecretOverlayBtn) {
  openSecretOverlayBtn.onclick = () => {
    overlayError.textContent = '';
    overlayPasswordInput.value = '';
    secretOverlay.classList.remove('hidden');
    overlayPasswordInput.focus();
  };
} else {
  console.warn('Button with ID #openSecretOverlay not found');
}

    overlayEnterBtn.onclick = () => {
      const val = overlayPasswordInput.value.trim();
      if(val === puzzleConfig.password){
        secretOverlay.classList.add('hidden');
        menu.classList.add('hidden');
        secretPage.classList.remove('hidden');
        document.body.classList.add('dark');
      } else {
        overlayError.textContent = 'Incorrect password, try again.';
      }
    };

    overlayCancelBtn.onclick = () => {
      secretOverlay.classList.add('hidden');
    };

    // Optional: Allow pressing Enter key to submit password
    overlayPasswordInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        overlayEnterBtn.click();
      }
    });
	
	backToMenuBtn?.addEventListener('click', () => {
  secretPage.classList.add('hidden');
    document.body.classList.remove('dark');  // <-- ADD THIS LINE

  showMenu();
});

inputs.forEach(input => {
  input.addEventListener('input', () => {
    if (!duck) return;
    duck.classList.remove('reacting');
    // Trigger reflow to restart animation
    void duck.offsetWidth;
    duck.classList.add('reacting');
  });
});

function launchConfetti(){
  const canvas = $('#confettiCanvas');
  const ctx    = canvas.getContext('2d');

  // Resize canvas to viewport
  canvas.width  = innerWidth;
  canvas.height = innerHeight;
  canvas.classList.remove('hidden');

  const pieces = [];
  for(let i=0;i<120;i++){
    pieces.push({
      x:Math.random()*canvas.width,
      y:Math.random()*canvas.height - canvas.height,
      size:6+Math.random()*6,
		dy: 1 + Math.random() * 2,
      dx:-2+Math.random()*4,
      hue:Math.random()*360
    });
  }

let frame=0;
const maxFrames = 1200;  // Or more for longer duration
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  pieces.forEach(p=>{
    ctx.fillStyle = `hsl(${p.hue},90%,60%)`;
    ctx.fillRect(p.x,p.y,p.size,p.size*0.6);
    p.y += p.dy;
    p.x += p.dx;
  });
  frame++;
  if(frame < maxFrames){
    requestAnimationFrame(draw);
  } else {
    canvas.classList.add('hidden');
  }
}
draw();
}

/* ----------------------------------------------------------
   DUCK helpers
   ---------------------------------------------------------- */
function startDuckGlow(){ duck.classList.add('duck-glow'); }
function stopDuckGlow() { duck.classList.remove('duck-glow'); }
function celebrateDuck(){
  duck.classList.remove('duck-celebrate'); // reset if running
  void duck.offsetWidth;                    // force reflow
  duck.classList.add('duck-celebrate');
  launchConfetti();
}

  // Emojis for puzzles
  const EMOJI = [
    'üê∂','üê±','ü¶ä','üêº','üê∏','üêµ','üêß','ü¶Ñ','üêô','üêù','ü¶ã','üê¢','üçé','üçã','üçá','üçì','ü•ë','ü•ï','üçï','üç™','‚öΩ','üèÄ','üé≤','üéπ','üöó','‚úàÔ∏è','üöÄ','üåà','‚≠ê','üî•','‚ùÑÔ∏è','üíé','üéÅ'
  ];

  // Game State for Puzzle 1 Stage 1
  let firstCard = null, lock = false, matched = 0, timer1, timeLeft1;

  // Game State for Puzzle 1 Stage 2
  let memoriseTimer, memoriseInterval, timer2, timeLeft2;
  let questionsAsked = 0;
  let questionMax;
  let questionSequence = [];
  let questionCurrentIndex;
  let cardPositions = []; // card emoji order by position index

  // Game State for Puzzle 3
  let seq3 = [], level = 0, acceptingInput = false, buttons3 = [], playerIndex = 0;

  // Sound utility
  // Create the audio context once

function playSound(freq = 440, duration = 150) {
  try {
    const osc = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    osc.frequency.value = freq;
    osc.type = 'triangle';
    osc.connect(gainNode);
    gainNode.connect(audioCtx.destination);

    const now = audioCtx.currentTime;
    gainNode.gain.setValueAtTime(0.2, now);
    gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration / 1000);

    osc.start(now);
    osc.stop(now + duration / 1000);
  } catch (e) {
    console.warn("Audio error", e);
  }
}

// Ensure audio works on user interaction
window.addEventListener('click', () => {
  if (audioCtx.state === 'suspended') {
    audioCtx.resume();
  }
}, { once: true });

  // Helper: show overlay message
function showMsg(text, btnText = 'OK', onClose = null) {
  overlayText.innerHTML = text;  // Use innerHTML instead of textContent
  overlayBtn.textContent = btnText;
  overlay.classList.remove('hidden');
  overlayBtn.onclick = () => {
    overlay.classList.add('hidden');
    if (onClose) onClose();
  };
}

  // Show/hide sections
  function hideAll() {
    menu.classList.add('hidden');
    puzzle1.classList.add('hidden');
    secretPage.classList.add('hidden');
    document.body.classList.remove('dark');
  }
 function showMenu() {
  hideAll();
  menu.classList.remove('hidden');

  // Try to scroll to top multiple times to counter mobile quirks
  function scrollToTopRepeated(times = 3, delay = 50) {
    if (times <= 0) return;
    window.scrollTo(0, 0);
    setTimeout(() => scrollToTopRepeated(times - 1, delay), delay);
  }
  scrollToTopRepeated();
}

  function scrollToTop() {
  window.scrollTo(0, 0);
}

  /* ===== Menu Buttons ===== */
  startPuzzle1Btn.onclick = () => {
    hideAll();
    puzzle1.classList.remove('hidden');
    startStage1();
  };



  /* ===== Secret Page Events ===== */
serialSubmitBtn?.addEventListener('click', () => {

  const val = serialInput.value.trim();
  if (val === puzzleConfig.serialNumber) {
    serialPrompt.classList.add('hidden');
    decryptUI.classList.remove('hidden');
    serialInput.value = '';
  } else {
    alert('Fel Serial Number ‚Üí Tillbaka till menyn');
    secretPage.classList.add('hidden');
    menu.classList.remove('hidden');
    decryptUI.classList.add('hidden');
    serialPrompt.classList.remove('hidden');
    serialInput.value = '';
  }
});

serialBackBtn?.addEventListener('click', () => {

  secretPage.classList.add('hidden');
  menu.classList.remove('hidden');

  decryptUI.classList.add('hidden');
  serialPrompt.classList.remove('hidden');
  serialInput.value = '';

  document.body.classList.remove('dark');
});

serialInput?.addEventListener('keydown', e => {
  if (e.key === 'Enter') {
    serialSubmitBtn?.click();
  }
});

  // Decrypt logic
function updateDecrypt(){
  // start glow as soon as user types
  startDuckGlow();

  const key   = codeBoxes.map(b => b.value.toUpperCase()).join('');
  const input = secretInput.value.trim();

  if(key==='DUCKS'){
    secretOutput.textContent = puzzleConfig.secretPhrases[input] || '[unknown message]';

    // If message actually decrypted (known phrase) => celebrate once
    if(puzzleConfig.secretPhrases[input]){
      celebrateDuck();
      // lil victory sound
      playSound(880,350);
    }
  }else{
    // Fake XOR
    secretOutput.textContent =
      '‚ñì‚ñí‚ñë '+input.split('').map(ch=>String.fromCharCode(ch.charCodeAt(0)^7)).join('')+' ‚ñë‚ñí‚ñì';
  }

  // stop glow after user pauses typing (200 ms debounce)
  clearTimeout(updateDecrypt._t);
  updateDecrypt._t = setTimeout(stopDuckGlow,200);
}
  codeBoxes.forEach(box => box.addEventListener('input', updateDecrypt));
 codeBoxes.forEach((box, index) => {
  box.addEventListener('input', () => {
    box.value = box.value.toUpperCase();
    if (box.value.length >= 1) {
      const nextBox = codeBoxes[index + 1];
      if (nextBox) nextBox.focus();
    }
  });
});
  secretInput.addEventListener('input', updateDecrypt);

  /* ===== Puzzle 1 Stage 1 ‚Äì Find pairs ===== */
  function startStage1() {
    firstCard = null;
    lock = false;
    matched = 0;
    timeLeft1 = config.stage1Time;
    time1Span.textContent = timeLeft1 + 's';
    stage1.classList.remove('hidden');
    stage2.classList.add('hidden');
    stage3.classList.add('hidden');

    // Prepare cards with pairs
    const cardsCount = config.pairs * 2;
    const selectedEmojis = shuffle(EMOJI).slice(0, config.pairs);
    const pairsArray = shuffle([...selectedEmojis, ...selectedEmojis]);

    // Clear previous
    grid1.innerHTML = '';
    grid1.style.gridTemplateColumns = `repeat(4, 1fr)`;

    // Create cards
    for (let i = 0; i < cardsCount; i++) {
      const card = document.createElement('div');
      card.className = 'card';
      card.dataset.emoji = pairsArray[i];
      card.textContent = '';
      card.setAttribute('aria-label', 'card');
      card.tabIndex = 0;

      card.onclick = () => {
        if (lock || card.classList.contains('flipped') || card.classList.contains('matched')) return;
        flipCard(card);
      };
      card.onkeydown = (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          card.click();
        }
      };
      grid1.appendChild(card);
    }

    // Timer countdown
    clearInterval(timer1);
    timer1 = setInterval(() => {
      timeLeft1--;
      time1Span.textContent = timeLeft1 + 's';
      if (timeLeft1 <= 0) {
        clearInterval(timer1);
        failStage1();
      }
    }, 1000);
  }
  // Flip card logic
  function flipCard(card) {
    if (lock) return;
    playSound(523); // C5
    card.classList.add('flipped', 'press-anim');
    card.textContent = card.dataset.emoji;
    setTimeout(() => card.classList.remove('press-anim'), 150);

    if (!firstCard) {
      firstCard = card;
      return;
    }
    lock = true;
    if (card.dataset.emoji === firstCard.dataset.emoji) {
      // Matched pair
      playSound(784); // G5
      card.classList.add('matched');
      firstCard.classList.add('matched');
      matched += 2;
      firstCard = null;
      lock = false;
      if (matched === config.pairs * 2) {
        clearInterval(timer1);
        showMsg('Steg 1 avklarat! G√•r √∂ver till Steg 2...', 'N√§sta', startStage2);
      }
    } else {
      // Not matched, flip back after delay
      playSound(196); // G3 low fail sound
      setTimeout(() => {
        card.classList.remove('flipped');
        card.textContent = '';
        firstCard.classList.remove('flipped');
        firstCard.textContent = '';
        firstCard = null;
        lock = false;
      }, 900);
    }
  }
  function failStage1() {
    showMsg('Tiden √§r ute! Prova steg 1 igen', 'Starta om', startStage1);
  }

  /* ===== Puzzle 1 Stage 2 ‚Äì Where is the emoji? ===== */
  
  // Track answered cards indexes
	let answeredCards = new Set();
  
  function startStage2() {
  stage1.classList.add('hidden');
  stage2.classList.remove('hidden');
  stage3.classList.add('hidden');

  // Clear previous timers and state
  clearInterval(memoriseTimer);
  clearInterval(timer2);
  lock = false;

  // Reset Puzzle 2 state
  questionCurrentIndex = 0;
  questionsAsked = 0;
  questionMax = config.seqCount;
  answeredCards = new Set();

  // Prepare cards
  const totalCards = config.stage2Cards;
  const selectedEmojis = shuffle(EMOJI).slice(0, totalCards);
  cardPositions = selectedEmojis.slice(); // stable order

  // Render cards face-up for memorization
  grid2.innerHTML = '';
  grid2.style.gridTemplateColumns = `repeat(4, 1fr)`;
  cardPositions.forEach(emoji => {
    const card = document.createElement('div');
    card.className = 'card done';
    card.textContent = emoji;
    card.style.background = ''; // reset background in case it was changed
    card.onclick = null; // remove any old handlers
    grid2.appendChild(card);
  });
// Disable clicks & pointer events during memorization phase
lock = true;
grid2.classList.add('disabled');
  instructions2.textContent = `Memorera korten! Du har ${config.memoriseTime} sekunder p√• dig.`;
  questionPrompt.textContent = '';
timerStage2El.classList.add('timer-invisible');    // hide but keep space

  // Start memorization countdown
  let memTimeLeft = config.memoriseTime;
  memoriseTimer = setInterval(() => {
    memTimeLeft--;
    instructions2.textContent = `Spelet startar om ${memTimeLeft} sekunder.`;
    if (memTimeLeft <= 0) {
      clearInterval(memoriseTimer);
      beginQuestionPhase();
    }
  }, 1000);
}

function failStage2() {
  clearInterval(memoriseTimer);
  clearInterval(timer2);
  lock = false;
  showMsg('Tiden √§r ute eller fel kort valt! Prova steg 2 igen.', 'Starta om', startStage2);
}

function beginQuestionPhase() {
 lock = false;
  grid2.classList.remove('disabled');
  grid2.querySelectorAll('.card').forEach(card => {
    card.textContent = '';
    card.classList.remove('done');
    card.style.cursor = 'pointer';
    card.style.background = '#f9d7e5';
    card.onclick = cardClickHandler;
  });
  instructions2.textContent = 'Vart var den h√§r emojin? Klicka p√• r√§tt kort.';
timerStage2El.classList.remove('timer-invisible'); // show timer
  timeLeft2 = config.stage2Time;
  time2Span.textContent = timeLeft2 + 's';

  // Shuffle a copy for the questions so cardPositions stays intact
  questionSequence = shuffle(cardPositions.slice()).slice(0, questionMax);
  questionCurrentIndex = 0;

  clearInterval(timer2);
  timer2 = setInterval(() => {
    timeLeft2--;
    time2Span.textContent = timeLeft2 + 's';
    if (timeLeft2 <= 0) {
      clearInterval(timer2);
      failStage2();
    }
  }, 1000);

  askNextQuestion();
}

function askNextQuestion() {
  if (questionCurrentIndex >= questionSequence.length) {
    clearInterval(timer2);
    showMsg('Steg 2 avklarat! G√• √∂ver till steg 3...', 'N√§sta', startStage3);
    return;
  }
  const emojiToFind = questionSequence[questionCurrentIndex];
  questionPrompt.innerHTML = `Vart √§r den h√§r emojin? <span class="bigEmoji">${emojiToFind}</span>`;
}

  
function cardClickHandler(e) {
  if (lock) return;
  const clickedCard = e.currentTarget;
  const clickedIndex = Array.from(grid2.children).indexOf(clickedCard);

  // Prevent clicking same card again if already answered
  if (answeredCards.has(clickedIndex)) return;

  lock = true;
  const emojiToFind = questionSequence[questionCurrentIndex];

  playSound(523);
  clickedCard.classList.add('press-anim');
  setTimeout(() => clickedCard.classList.remove('press-anim'), 150);

  if (cardPositions[clickedIndex] === emojiToFind) {
    // Correct
    clickedCard.textContent = emojiToFind;
    clickedCard.style.background = '#a2d9a2'; // green background for correct
    clickedCard.style.cursor = 'default';
    answeredCards.add(clickedIndex);

    questionCurrentIndex++;
    lock = false;

    if (questionCurrentIndex >= questionSequence.length) {
      clearInterval(timer2);
      showMsg('Stage 2 avklart! Nu b√∂rjar Stage 3...', 'N√§sta', startStage3);
    } else {
      askNextQuestion();
    }
  } else {
    // Wrong
    playSound(196);
    showMsg('Fel kort! Prova steg 2 igen.', 'Starta om', startStage2);
  }
}

  function failStage2(){
    lock=false;clearInterval(timer2);
    showMsg('Tiden √§r ute! Prova igen...','Starta om',startStage2);
  }

  /* ===== Puzzle 1 Stage 3 ‚Äì Simon Says ===== */
function startStage3() {
  stage1.classList.add('hidden');
  stage2.classList.add('hidden');
  stage3.classList.remove('hidden');

  startStage3Btn.style.display = 'inline-block';  // Show start button
grid3.classList.add('hidden');  // hide with class
  info3.style.display = 'none';                    // Hide info text
  document.getElementById('levelInfo').style.display = 'none'; // Hide level info

  // Reset game state
  seq3 = [];
  level = 1;
  playerIndex = 0;
  acceptingInput = false;
  buttons3 = [];
  levelNum.textContent = level;
}

startStage3Btn.onclick = () => {
  startStage3Btn.style.display = 'none';   // Hide start button
grid3.classList.remove('hidden');  // show by removing hidden class
  info3.style.display = 'block';            // Show info
  document.getElementById('levelInfo').style.display = 'block'; // Show level info

  levelNum.textContent = level;
  grid3.innerHTML = '';
// grid3.style.gridTemplateColumns = `repeat(4, 1fr)`;

  const icons = shuffle(EMOJI).slice(0, config.stage3Icons);

  buttons3 = [];
  icons.forEach(icon => {
    const btn = document.createElement('button');
	btn.className = 'card iconBtn disabled';
    btn.textContent = icon;
    btn.dataset.icon = icon;
    btn.disabled = false;

	  startStage3Btn.style.display = 'none'; // Hide start button
  info3.style.display = 'block';
  grid3.style.display = 'grid';
  levelNum.style.display = 'inline'; // or whatever shows level info

    btn.onclick = () => {
      if (!acceptingInput) return;
      playSound(523);
      animatePress(btn);
      if (icon === seq3[playerIndex]) {
        playerIndex++;
        if (playerIndex === seq3.length) {
          level++;
          if (level > config.stage3Max) {
		showMsg(
				`üéâ Grattis! Du har klarat alla steg! üéâ\nL√∂senordet √§r:\n<strong>${puzzleConfig.password}</strong>`, 
				'Avsluta', 
				showMenu
				);
            return;
          }
          levelNum.textContent = level;
          acceptingInput = false;
          buttons3.forEach(b => b.classList.add('disabled'));
          playerIndex = 0;
          setTimeout(() => {
            nextSimonSequence();
          }, 1000);
        }
      } else {
        playSound(196);
        showMsg('Fel kort! Prova steg 3 igen.', 'Starta om', startStage3);
      }
    };

    buttons3.push(btn);
    grid3.appendChild(btn);
  });
 // Show ‚ÄúGet ready...‚Äù message
  info3.textContent = 'G√∂r dig redo...';
  setTimeout(() => {
    info3.textContent = 'Titta p√• sekvensen‚Ä¶';
    nextSimonSequence();
  }, 1500); // 1.5 seconds delay before sequence starts
};

async function nextSimonSequence() {

  const availableIcons = buttons3.map(b => b.dataset.icon);
  const newIcon = availableIcons[Math.floor(Math.random() * availableIcons.length)];
  seq3.push(newIcon);
	buttons3.forEach(b => b.classList.remove('active', 'press-anim'));

  info3.textContent = 'Titta p√• sekvensen‚Ä¶';
  acceptingInput = false;
  buttons3.forEach(b => b.classList.add('disabled'));
  

  
// show the sequence
for (const icon of seq3) {
  const btn = buttons3.find(b => b.dataset.icon === icon);

  // Force clear in case it's still stuck
  btn.classList.remove('active', 'press-anim');

  // Force reflow (important for Safari to restart animation)
  void btn.offsetWidth;

  btn.classList.add('active');
  playSound(523 + Math.random() * 200);
  await delay(config.stage3Show);
  btn.classList.remove('active');
  await delay(250);
}

  /* --- EXTRA one-shot clean-up --- */
  buttons3.forEach(b => b.classList.remove('active', 'press-anim'));

  info3.textContent = 'Din tur! Repetera sekvensen';
  acceptingInput = true;
  buttons3.forEach(b => b.classList.remove('disabled'));
  playerIndex = 0;
}

function animatePress(el) {
  if (!el) return;

  el.classList.remove('press-anim');

  // Schedule the add in the next frame to ensure clean animation
  requestAnimationFrame(() => {
    el.classList.add('press-anim');

    setTimeout(() => {
      el.classList.remove('press-anim');
    }, 150); // Match with CSS duration
  });
}

  /* ===== Initialize ===== */
  window.addEventListener('load', () => {
  setTimeout(() => window.scrollTo(0, 0), 100);
});
  showMenu();
});
</script>
</body>
</html>